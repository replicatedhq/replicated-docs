import SupportBundleIntro from "../partials/support-bundles/_ec-support-bundle-intro.mdx"
import EmbeddedClusterSupportBundle from "../partials/support-bundles/_generate-bundle-ec.mdx"

# Troubleshooting Embedded Cluster

This topic provides information about troubleshooting Replicated Embedded Cluster.

## Troubleshoot with Support Bundles

This section includes information about how to collect support bundles for Embedded Cluster installations. For more information about support bundles, see [About Preflight Checks and Support Bundles](/vendor/preflight-support-bundle-about).

### About the Default Embedded Cluster Support Bundle

<SupportBundleIntro/>

<EmbeddedClusterSupportBundle/>

## View Logs

You can view logs for both Embedded Cluster and the systemd k0s service running in the cluster to help troubleshoot installation errors.

### View Logs for Embedded Cluster

To view installation logs for Embedded Cluster:

1. SSH onto the installation VM.

1. Navigate to `/var/log/embedded-cluster` and open the `.log` file to view logs. 

### View k0s Logs

You can use the journalctl command line tool to access logs for systemd services, including k0s.

To use journalctl to view k0s logs:

1. SSH onto the installation VM.

1. Use journalctl to view logs for the k0s systemd service that was deployed by Embedded Cluster.

    **Example:**

    ```bash
    journalctl -u k0scontroller
    ```

## Troubleshoot Errors

This section provides troubleshooting advice for common errors.

### Installation failure when NVIDIA GPU Operator is included as a Helm extension

#### Symptom

A release that includes that includes the NVIDIA GPU Operator as a Helm extensions fails to install.

#### Cause 

If there are any containerd services on the host, the NVIDIA GPU Operator will generate an invalid containerd config, causing the installation to fail.

#### Solution

Remove any existing containerd services that are running on the host (such as those deployed by Docker) before attempting to install the release with Embedded Cluster.

For more information, see [NVIDIA GPU Operator](/vendor/embedded-using#nvidia-gpu-operator) in _Using Embedded Cluster_.

### Calico networking issues 

#### Symptom

The following are possible symptoms of Calico networking issues:

* The pod is stuck in a CrashLoopBackOff state with failed health checks:

    ```
    Warning Unhealthy 6h51m (x3 over 6h52m) kubelet Liveness probe failed: Get "http://<ip:port>/readyz": dial tcp <ip:port>: connect: no route to host
    Warning Unhealthy 6h51m (x19 over 6h52m) kubelet Readiness probe failed: Get "http://<ip:port>/readyz": dial tcp <ip:port>: connect: no route to host
    ....
    Unhealthy               pod/registry-dc699cbcf-pkkbr     Readiness probe failed: Get "https://<ip:port>/": net/http: request canceled while waiting for connection (Client.Timeout exceeded while awaiting headers)
    Unhealthy               pod/registry-dc699cbcf-pkkbr     Liveness probe failed: Get "https://<ip:port>/": net/http: request canceled while waiting for connection (Client.Timeout exceeded while awaiting headers)
    ...
    ```

* The pod log contains an I/O timeout:

    ```
    server APIs: config.k8ssandra.io/v1beta1: Get \"https://***HIDDEN***:443/apis/config.k8ssandra.io/v1beta1\": dial tcp ***HIDDEN***:443: i/o timeout"}
    ```

#### Cause 

Reasons can include:

* podCIDR and serviceCIDR overlapping with the host network CIDR.

* Incorrect kernel parameters values.

* VXLAN traffic getting dropped. By default, Calico uses VXLAN as the overlay networking protocol, with Always mode. This mode encapsulates all pod-to-pod traffic in VXLAN packets. If for some reasons, the VXLAN packets get filtered by the network, the pod will not able to communicate with other pods.

#### Solution

To troubleshoot:

* **podCIDR and serviceCIDR overlapping with the host network CIDR:**

    1. Run the following command to verify:
        ```
        cat /etc/k0s/k0s.yaml | grep -i cidr
            podCIDR: 10.244.0.0/17
            serviceCIDR: 10.244.128.0/17
        ```
        The default podCIDR is 10.244.0.0/16 and serviceCIDR is 10.96.0.0/12.

    1. View pod network interfaces excluding Calico interfaces, and ensure no overlapping CIDRs.
        ```
        ip route | grep -v cali
        default via 10.152.0.1 dev ens4 proto dhcp src 10.152.0.4 metric 100
        10.152.0.1 dev ens4 proto dhcp scope link src 10.152.0.4 metric 100
        blackhole 10.244.101.192/26 proto 80
        169.254.169.254 via 10.152.0.1 dev ens4 proto dhcp src 10.152.0.4 metric 100
        ```

    1. Reset and reboot the installation. See [Reset a Node](/vendor/embedded-overview#reset-a-node)

    1. Reinstall the application with different CIDRs using the `--cidr` flag:

        ```bash
        sudo ./APP_SLUG install --license license.yaml --cidr 172.16.136.0/16
        ```
        Where `APP_SLUG` is the unique slug for the installed application.

        For more information, see [Embedded Cluster Install Options](/reference/embedded-cluster-install).

* **Incorrect kernel parameters values:**

    1. Use sysctl to verify that these parameters are set correctly:

        ```bash
        net.ipv4.conf.default.arp_filter = 0
        net.ipv4.conf.default.arp_ignore = 0
        net.ipv4.ip_forward = 1
        ```            
    
    1. If the values are not set correctly, run the following command to set them:

        ```
        sysctl -w net.ipv4.conf.default.arp_filter=0
        sysctl -w net.ipv4.conf.default.arp_ignore=0
        sysctl -w net.ipv4.ip_forward=1


        echo "net.ipv4.conf.default.arp_filter=0" >> /etc/sysctl.conf
        echo "net.ipv4.conf.default.arp_ignore=0" >> /etc/sysctl.conf
        echo "net.ipv4.ip_forward=1" >> /etc/sysctl.conf

        sysctl -p
        ```

    1. Reset and reboot the installation. See [Reset a Node](/vendor/embedded-overview#reset-a-node)

    1. Re-run the installation.

* **VXLAN traffic getting dropped:**

    As a temporary troubleshooting measure, set the mode to CrossSubnet and see if the issue persists. This mode only encapsulates traffic between pods across different subnets with VXLAN.

        ```bash
        kubectl patch ippool default-ipv4-ippool --type=merge -p '{"spec": {"vxlanMode": "CrossSubnet"}}'
        ```
    
    If this resolves the connectivity issues, there is likely an underlying network configuration problem with VXLAN traffic that should be addressed.